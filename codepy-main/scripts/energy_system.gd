extends Node

## Energy System - Manages player energy for adventure mode progression
## Energy regenerates over time and is consumed/generated by gameplay

# Energy limits and regeneration
const MAX_ENERGY: int = 100
const ENERGY_REGEN_RATE: float = 10.0  # Energy per minute
const ENERGY_REGEN_TICK: float = 0.1  # Check energy regen every X seconds

# Energy costs per game mode (in energy units)
const SINGLE_PLAYER_COST: int = 15
const MULTIPLAYER_COST: int = 20
const EASY_DIFFICULTY_MULTIPLIER: float = 0.8  # 20% discount on easy
const MEDIUM_DIFFICULTY_MULTIPLIER: float = 1.0  # Normal cost
const HARD_DIFFICULTY_MULTIPLIER: float = 1.3  # 30% premium on hard

# Current energy and regeneration
var current_energy: int = 100
var last_energy_regen_time: float = 0.0
var total_energy_earned: int = 0  # Track lifetime energy earned
var total_energy_spent: int = 0   # Track lifetime energy spent

# Signals
signal energy_changed(new_energy: int)
signal energy_depleted
signal low_energy(current: int)  # Signal when energy gets low

func _ready() -> void:
	# Load energy from save file if exists
	_load_energy_data()
	last_energy_regen_time = Time.get_ticks_msec() / 1000.0

func _process(_delta: float) -> void:
	_update_energy_regeneration()

## Get current energy level
func get_current_energy() -> int:
	return current_energy

## Get maximum energy
func get_max_energy() -> int:
	return MAX_ENERGY

## Calculate energy cost for a game mode
func calculate_energy_cost(game_mode: String, difficulty: String) -> int:
	var base_cost = 0
	var multiplier = 1.0
	
	# Determine base cost
	match game_mode:
		"single_player":
			base_cost = SINGLE_PLAYER_COST
		"multiplayer":
			base_cost = MULTIPLAYER_COST
		"adventure":
			base_cost = 10  # Adventures cost less but give more rewards
		_:
			base_cost = SINGLE_PLAYER_COST
	
	# Apply difficulty multiplier
	match difficulty.to_lower():
		"easy":
			multiplier = EASY_DIFFICULTY_MULTIPLIER
		"medium":
			multiplier = MEDIUM_DIFFICULTY_MULTIPLIER
		"hard":
			multiplier = HARD_DIFFICULTY_MULTIPLIER
	
	return int(base_cost * multiplier)

## Consume energy for playing a game
func consume_energy(amount: int, reason: String = "") -> bool:
	if current_energy < amount:
		emit_signal("energy_depleted")
		return false
	
	current_energy -= amount
	total_energy_spent += amount
	emit_signal("energy_changed", current_energy)
	
	if current_energy < 20:
		emit_signal("low_energy", current_energy)
	
	_save_energy_data()
	return true

## Gain energy from completing challenges
func gain_energy(amount: int, reason: String = "") -> void:
	current_energy = min(current_energy + amount, MAX_ENERGY)
	total_energy_earned += amount
	emit_signal("energy_changed", current_energy)
	_save_energy_data()

## Gain bonus energy for difficult achievements
func gain_bonus_energy(base_amount: int, multiplier: float = 1.0) -> void:
	var bonus = int(base_amount * multiplier)
	gain_energy(bonus, "bonus")

## Refill energy to maximum
func refill_energy() -> void:
	current_energy = MAX_ENERGY
	emit_signal("energy_changed", current_energy)
	_save_energy_data()

## Reset energy (for testing or special events)
func reset_energy_to_max() -> void:
	refill_energy()

## Check if player has enough energy for an action
func has_enough_energy(required: int) -> bool:
	return current_energy >= required

## Get energy regeneration rate (energy per minute)
func get_regen_rate() -> float:
	return ENERGY_REGEN_RATE

## Update energy regeneration over time
func _update_energy_regeneration() -> void:
	var current_time = Time.get_ticks_msec() / 1000.0
	var time_delta = current_time - last_energy_regen_time
	
	# Regenerate energy based on elapsed time
	if time_delta >= ENERGY_REGEN_TICK:
		var energy_to_gain = int((ENERGY_REGEN_RATE / 60.0) * time_delta)
		
		if energy_to_gain > 0 and current_energy < MAX_ENERGY:
			current_energy = min(current_energy + energy_to_gain, MAX_ENERGY)
			emit_signal("energy_changed", current_energy)
			_save_energy_data()
		
		last_energy_regen_time = current_time

## Save energy data to user directory
func _save_energy_data() -> void:
	var data = {
		"current_energy": current_energy,
		"total_energy_earned": total_energy_earned,
		"total_energy_spent": total_energy_spent,
		"last_regen_time": Time.get_ticks_msec() / 1000.0
	}
	
	var json = JSON.stringify(data)
	var file = FileAccess.open("user://energy_data.json", FileAccess.WRITE)
	if file:
		file.store_string(json)

## Load energy data from user directory
func _load_energy_data() -> void:
	if ResourceLoader.exists("user://energy_data.json"):
		var file = FileAccess.open("user://energy_data.json", FileAccess.READ)
		if file:
			var json_string = file.get_as_text()
			var json = JSON.new()
			if json.parse(json_string) == OK:
				var data = json.get_data()
				current_energy = data.get("current_energy", MAX_ENERGY)
				total_energy_earned = data.get("total_energy_earned", 0)
				total_energy_spent = data.get("total_energy_spent", 0)
				
				# Handle time-based regeneration since last save
				var last_regen = data.get("last_regen_time", 0.0)
				var current_time = Time.get_ticks_msec() / 1000.0
				var elapsed = current_time - last_regen
				
				if elapsed > 0:
					var regen_amount = int((ENERGY_REGEN_RATE / 60.0) * elapsed)
					current_energy = min(current_energy + regen_amount, MAX_ENERGY)
				
				emit_signal("energy_changed", current_energy)

## Clear all energy data (for reset)
func clear_energy_data() -> void:
	current_energy = MAX_ENERGY
	total_energy_earned = 0
	total_energy_spent = 0
	_save_energy_data()
